
<!-- saved from url=(0046)http://www.karlsims.com/papers/siggraph91.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Karl Sims: Artifical Evolution for Computer Graphics</title>
</head>
<body><p>
 </p><hr> 
Published in <i>Computer Graphics</i>, <b>25</b>(4), July 1991, pp. 319-328.<br>(ACM SIGGRAPH '91 Conference Proceedings, Las Vegas, Nevada, July 1991.)
<hr> <p>
</p><p>
</p><center>
<h2>Artificial Evolution for Computer Graphics<p></p><p></p></h2>

Karl Sims<p>
</p><p>
Thinking Machines Corporation
</p><p><br>
</p></center>
<p>
</p><h3>1 &nbsp; ABSTRACT</h3>
<p>
This paper describes how evolutionary techniques of variation and selection
can be used to create complex simulated structures, textures, and motions
for use in computer graphics and animation.  Interactive selection, based
on visual perception of procedurally generated results, allows the user to
direct simulated evolutions in preferred directions.  Several examples
using these methods have been implemented and are described.  3D plant
structures are grown using fixed sets of genetic parameters.  Images, solid
textures, and animations are created using mutating symbolic lisp
expressions.  Genotypes consisting of symbolic expressions are presented as
an attempt to surpass the limitations of fixed-length genotypes with
predefined expression rules.  It is proposed that artificial evolution has
potential as a powerful tool for achieving flexible complexity with a
minimum of user input and knowledge of details.
</p><p>
</p><h3>2 &nbsp; INTRODUCTION</h3>
<p>
Procedural models are increasingly employed in computer graphics to create
scenes and animations having high degrees of complexity.  A price paid for
this complexity is that the user often loses the ability to maintain
sufficient control over the results.  Procedural models can also have
limitations because the details of the procedure must be conceived,
understood, and designed by a human.  The techniques presented here
contribute towards solutions to these problems by enabling ``evolution'' of
procedural models using interactive ``perceptual selection.''  Although
they do not give complete control over every detail of the results, they do
permit the creation of a large variety of complex entities which are still
user directed, and the user is not required to understand the underlying
creation process involved.
</p><p>
Many years ago Charles Darwin proposed the theory that all species came
about via the process of evolution <a href="http://www.karlsims.com/papers/siggraph91.html#Darwin">[2]</a>.  Evolution is now
considered not only powerful enough to bring about biological entities as
complex as humans and consciousness, but also useful in simulation to
create algorithms and structures of higher levels of complexity than could
easily be built by design.  Genetic algorithms have shown to be a useful
method of searching large spaces using simulated systems of variation and
selection <a href="http://www.karlsims.com/papers/siggraph91.html#GA89">[23]</a><a href="http://www.karlsims.com/papers/siggraph91.html#GA87">[7]</a><a href="http://www.karlsims.com/papers/siggraph91.html#GA85">[6]</a><a href="http://www.karlsims.com/papers/siggraph91.html#Goldberg">[5]</a>.  In The Blind Watchmaker, Dawkins
has demonstrated the power of Darwinism with a simulated evolution of 2D
branching structures made from sets of genetic parameters.  The user
selects the ``biomorphs'' that survive and reproduce to create each new
generation <a href="http://www.karlsims.com/papers/siggraph91.html#Dawkins87">[4]</a><a href="http://www.karlsims.com/papers/siggraph91.html#Dawkins86">[3]</a>.  Latham and Todd have applied these
concepts to help generate computer sculptures made with constructive solid
geometry techniques <a href="http://www.karlsims.com/papers/siggraph91.html#Todd">[28]</a><a href="http://www.karlsims.com/papers/siggraph91.html#Haggerty">[9]</a>.
</p><p>
Variations on these techniques are used here with the emphasis on the
potential of creating forms, textures, and motions that are useful in the
production of computer graphics and animation, and also on the potential of
using representations that are not bounded by a fixed space of possible
results.
</p><p>
</p><h3>2.1 &nbsp; Evolution</h3>
<p>
Both biological and simulated evolutions involve the basic concepts of
genotype and phenotype, and the processes of expression, selection, and
reproduction with variation.
</p><p>
The <em>genotype</em> is the genetic information that codes for the creation
of an individual.  In biological systems, genotypes are normally composed
of DNA.  In simulated evolutions there are many possible representations of
genotypes, such as strings of binary digits, sets of procedural parameters,
or symbolic expressions.  The <em>phenotype</em> is the individual itself, or
the form that results from the developmental rules and the genotype.  <em>Expression</em> is the process by which the phenotype is generated from the
genotype.  For example, expression can be a biological developmental
process that reads and executes the information from DNA strands, or a set
of procedural rules that utilize a set of genetic parameters to create a
simulated structure.  Usually, there is a significant amplification of
information between the genotype and phenotype.
</p><p>
<em>Selection</em> is the process by which the fitness of phenotypes is
determined.  The likelihood of survival and the number of new offspring an
individual generates is proportional to its fitness measure.  <em>Fitness</em>
is simply the ability of an organism to survive and reproduce.  In
simulation, it can be calculated by an explicitly defined fitness
evaluation function, or it can be provided by a human observer as it is in
this work.
</p><p>
<em>Reproduction</em> is the process by which new genotypes are generated from
an existing genotype or genotypes.  For evolution to progress there must be
<em>variation</em> or mutations in new genotypes with some frequency.
Mutations are usually probabilistic as opposed to deterministic.  Note that
selection is, in general, non-random and is performed on phenotypes;
variation is usually random and is performed on the corresponding genotypes
[See figure 1].
</p><p>
</p><center>
<img src="./Karl Sims_ Artifical Evolution for Computer Graphics_files/ksf01.gif" width="60%"><p>
Figure 1: Phenotype selection, genotype reproduction.
</p></center>
<p>
The repeated cycle of reproduction with variation and selection of the most
fit individuals drives the evolution of a population towards higher and
higher levels of fitness.
</p><p>
<em>Sexual combination</em> can allow genetic material of more than one parent
to be mixed together in some way to create new genotypes.  This permits
features to evolve independently and later be combined into a single
individual.  Although it is not necessary for evolution to occur, it is a
valuable practice that can enhance progress in both biological and
simulated evolutions.
</p><p>
</p><h3>2.2 &nbsp; Genetic Algorithms</h3>
<p>
Genetic algorithms were first developed by Holland <a href="http://www.karlsims.com/papers/siggraph91.html#Holland">[11]</a> as robust
searching techniques in which populations of test points are evolved by
random variation and selection.  They have become widely used in a number
of applications to find optima in very large search spaces
<a href="http://www.karlsims.com/papers/siggraph91.html#GA89">[23]</a><a href="http://www.karlsims.com/papers/siggraph91.html#GA87">[7]</a><a href="http://www.karlsims.com/papers/siggraph91.html#GA85">[6]</a>.
</p><p>
Genetic algorithms differ from the examples presented in this paper in that
they usually utilize an explicit analytic function to measure the fitness
of phenotypes.  Since it is difficult to automatically measure the
aesthetic visual success of simulated objects or images, here the fitness
is provided by a human user based on visual perception.  Some combinations
of automatic selection and interactive selection are also utilized.
</p><p>
Population sizes used for genetic algorithms are usually fairly large (100
to 1000 or more) to allow searching of many test points and avoiding only
local optima.  At each generation, many individuals survive and reproduce
to create the next generation.  For the examples presented in this paper,
the success of a solution is dependent on human opinion, therefore there is
no single global optimum.  Many local optima are potentially interesting
solutions.  For this reason, and also because of user interface
practicality, a smaller population size has been used (20 - 40), and only
one or two individuals are chosen to reproduce for each new generation.
</p><p>
Genotypes used in genetic algorithms traditionally consist of fixed-length
character strings used by fixed expression rules.  This is appropriate for
searching predefined dimensional spaces for optimum solutions, but these
restrictions are sometimes limiting.  Koza <a href="http://www.karlsims.com/papers/siggraph91.html#Koza90b">[13]</a><a href="http://www.karlsims.com/papers/siggraph91.html#Koza90a">[12]</a> has used
hierarchical lisp expressions as genotypes such that the dimensionality of
the search space itself can be extended to successfully solve problems such
as artificial ant navigation and game strategies.  Discovery systems, such
as AM, Eurisko, and Cyrano, also utilize a form of mutating lisp programs
<a href="http://www.karlsims.com/papers/siggraph91.html#Lenat">[14]</a><a href="http://www.karlsims.com/papers/siggraph91.html#Haase">[8]</a>.  The examples of evolving images, volume textures, and
animations presented here also use genotypic representations composed of
lisp expressions, although the set of functions used includes various vector
transformations, noise generators, and image processing operations, as well
as standard numerical functions.
</p><p>
In the next section, techniques for using artificial evolution to explore
samples in parameter spaces are discussed.  In section 4, examples of
evolving images, volume textures, and animations which utilize mutating
symbolic expressions as genotypes are presented.  Finally, results,
suggestions for future work, and conclusions are given in the last three
sections.
</p><p>
</p><h3>3 &nbsp; EXPLORING PARAMETER SPACES</h3>
<p>
Procedural models such as fractals, graftals, and procedural texturing
allow a user to create a high degree of complexity with relatively simple
input information <a href="http://www.karlsims.com/papers/siggraph91.html#Smith">[25]</a><a href="http://www.karlsims.com/papers/siggraph91.html#Prusinkiewicz">[21]</a><a href="http://www.karlsims.com/papers/siggraph91.html#Perlin">[19]</a><a href="http://www.karlsims.com/papers/siggraph91.html#Peachey">[18]</a>.  One method of
procedural structure creation involves a set of N input parameters each
of which has an effect on a developmental process which assembles the
structure.  The set of possible structures corresponds to the
N-dimensional space of possible parameter values.  Consider an array of
knobs, each controlling one parameter, that can be experimentally turned to
adjust the results.  As more options are added to the procedure for more
variation of results, the number of input parameters grows and it can
become increasingly difficult for a user to predict the effects of
adjusting particular parameters and combinations of parameters, and to
adjust the knobs effectively by hand.
</p><p>
An alternative approach is to sample randomly in the neighborhood of a
currently existing parameter set by making random alterations to a
parameter or several parameters, then inspect and select the best sample or
samples of those presented.  This allows exploration through the parameter
space in incremental arbitrary directions without requiring knowledge of
the specific effects of each parameter.  This is artificial evolution in
which the genotype is the parameter set, and the phenotype is the resulting
structure.  Selection is performed by the user picking preferred phenotypes
from groups of samples, and as long as the samples can be generated and
displayed quickly enough, it can be a useful technique.
</p><p>
</p><h3>3.1 &nbsp; Evolving 3D Plant Structures</h3>
<p>
The first example of artificial evolution involves 3D plant structures
which can be grown using a set of ``genetic'' parameters.  Plant generation
algorithms of various types have been shown to be useful examples of
procedurally generated structures
<a href="http://www.karlsims.com/papers/siggraph91.html#Viennot">[29]</a><a href="http://www.karlsims.com/papers/siggraph91.html#Smith">[25]</a><a href="http://www.karlsims.com/papers/siggraph91.html#Reffye">[22]</a><a href="http://www.karlsims.com/papers/siggraph91.html#Prusinkiewicz">[21]</a><a href="http://www.karlsims.com/papers/siggraph91.html#Oppenheimer">[16]</a><a href="http://www.karlsims.com/papers/siggraph91.html#Aono">[1]</a>.  The model used
in this work is described briefly below, but details have been omitted as
the emphasis is on the evolutionary process.
</p><p>
Parameters describing fractal limits, branching factors, scaling,
stochastic contributions, etc., are used to generate 3-dimensional tree
structures consisting of connected segments.  Growth rules use 21 genetic
parameters and the hierarchy location of each segment in the tree to
determine how fast that segment should grow, when it should generate new
buds, and in which directions.  The tree structures are grown in
arbitrarily small increments for smooth simulation of development.
</p><p>
After a desirable tree structure has been evolved using interactive
selection and the mutation methods described below, its phenotype can be
saved for further manipulation.  Solid polygonal branches can be generated
with connected cylinders and cone shapes, and leaves can be generated by
connecting sets of peripheral nodes with polygonal surfaces.  Shading
parameters, color, and bump textures can be assigned to make bark and leaf
surfaces.  These additional properties could also be selected and adjusted
using artificial evolution, but due to the longer computation times
involved to test samples, these parameters were adjusted by hand.  In some
cases, leaf shapes were evolved independently and then explicitly added to
the tip segments of other evolved plant structures.  A forest of plant
structures created using these methods is shown in figure 3.
</p><p>
</p><h3>3.2 &nbsp; Mutating Parameter Sets</h3>
<p>
For artificial evolution of parameter sets to occur, they must be
reproduced with some probability of mutation.  There are many possible
methods for mutating parameter sets.  The technique used here involves
normalizing each parameter for a genetic value between .0 and 1.0, and then
copying each genetic value or gene, g<sub>i</sub>, from the parent to the child
with a certain probability of mutation, m.  A mutation is achieved by
adding a random amount, +-d, to the gene.  So, a new genotype, G', is
created using each gene, g<sub>i</sub>, of a parent genotype, G, as follows:
</p><p>
</p><pre>	For each g<sub>i</sub>
	  If <i>rand</i>(.0,1.0) &lt; m
	     then g'<sub>i</sub> = g<sub>i</sub> + <i>rand</i>(-d, d)
	          clamp or wrap g'<sub>i</sub> to legal bounds.
	     else g'<sub>i</sub> = g<sub>i</sub>
</pre>
<p>
The normalized values are scaled, offset, and optionally squared to give
the parameter values actually used.  This allows the mutation distances,
+-d, to be proportional to the scale of the range of valid parameter
values.  Squaring or raising some values to even higher powers can be
useful because it causes more sensitivity in the lower region of the range
of parameter values.  The mutation rate and amount are easily adjusted, but
are commonly useful at much higher values than in natural systems (m=0.2,
d=0.4).  The random value between -d and d might preferably be found
using a Gaussian distribution instead of this simple linear distribution,
giving smaller mutations more likelihood than larger ones.
</p><p>
</p><h3>3.3 &nbsp; Mating Parameter Sets</h3>
<p>
When two parameter sets are found that both create structures with
different successful features, it is sometimes desirable to combine these
features into a single structure.  This can be accomplished by mating them.
Reproducing two parameter sets with sexual combination can be performed in
many ways.  Four possible methods are listed below with some of their
resulting effects:
</p><p>
</p><ol>
<li>
<em>Crossovers</em> can be performed by sequentially copying genes from one
parent, but with some frequency the source genotype is switched to the
other parent.  This causes adjacent genes to be more likely to stick
together than genes at opposite ends of the sequence.  Each pair of genes
has a <em>linkage</em> probability depending on their distance from each
other.<p>
</p></li><li>
Each gene can be independently copied from one parent or the other with
equal probability.  If the parent genes each correspond to a point in
N-dimensional genetic space, then the genes of the possible children using
this method correspond to the 2<sup>N</sup> corners of the N-dimensional rectangular
solid connecting the two parent points.  This method is the most commonly
used in this work and is demonstrated in figure 2.  Two parent plant
structures are shown in the upper left boxes, and the remaining forms are
their children.<p>
</p></li><li>
Each gene can receive a random percentage, p, of one parent's genes,
and a 1 - p percentage of the other parent's genes.  If the percentage is
the same for each gene, linear <em>interpolation</em> between the parent
genotypes results, and the children will fall randomly on the line between
the N-dimensional points of the parents.  If evenly spaced samples along
this line were generated, a <em>genetic dissolve</em> could be made that would
cause a smooth transition between the parent phenotypes if the changing
parameters had continuous effects on the phenotypes.  This is an example of
utilizing the underlying genetic representation for specific manipulation
of the results.  Interpolation could also be performed with three parents
to create children that fall on a triangular region of a plane in the
N-dimensional genetic space. <p>
</p></li><li>
Finally, each new gene can receive a random value between the two parent
values of that gene.  This is like the interpolation scheme above, except
each gene is independently interpolated between the parent genes.  This
method results in possible children anywhere within the N-dimensional
rectangular solid connecting the parent points.
</li></ol>
<p>
Mutating and mating parameter sets allow a user to explore and combine
samples in a given parameter space.  In the next section, methods are
presented that allow mutations to add new parameters and extend the space,
instead of simply adjusting existing parameter values.
</p><p>
</p><center>
<img src="./Karl Sims_ Artifical Evolution for Computer Graphics_files/ksf02.gif" width="60%"><p>
Figure 2: Mating plant structures.
</p></center>
<p>
</p><center>
<img src="./Karl Sims_ Artifical Evolution for Computer Graphics_files/ksf03.gif" width="60%"><p>
Figure 3: Forest of ``evolved'' plants.
</p></center>
<p>
</p><h3>4 &nbsp; SYMBOLIC EXPRESSIONS AS GENOTYPES</h3>
<p>
A limitation of genotypes consisting of a fixed number of parameters and
fixed expression rules as described above is that there are solid
boundaries on the set of possible phenotypes.  There is no possibility for
the evolution of a new developmental rule or a new parameter.  There is no
way for the genetic space to be extended beyond its original definition -
the N-dimensional genetic space will remain only N-dimensional.
</p><p>
To surpass this limitation, it is desirable to include procedural
information in the genotype instead of just parameter data, and the
procedural and data elements of the genotype should not be restricted to a
specific structure or size.
</p><p>
Symbolic lisp expressions are used as genotypes in an attempt to meet these
needs.  A set of lisp functions and a set of argument generators are used
to create arbitrary expressions which can be mutated, evolved, and
evaluated to generate phenotypes.  Some mutations can create larger
expressions with new parameters and extend the space of possible
phenotypes, while others just adjust existing parts of the expression.
Details of this process are best described by the examples below.
</p><p>
</p><h3>4.1 &nbsp; Evolving Images</h3>
<p>
The second example of artificial evolution involves the generation of
textures by mutating symbolic expressions.  Equations that calculate a
color for each pixel coordinate <i>(x,y)</i> are evolved using a <em>function
set</em> containing some standard common lisp functions <a href="http://www.karlsims.com/papers/siggraph91.html#Steele">[26]</a>, vector
transformations, procedural noise generators, and image processing
operations:
</p><p>
</p><pre><i>
	+, -, *, /, mod, round, min, max, abs, expt, log, and, 
        or, xor, sin, cos, atan, if, dissolve, hsv-to-rgb, vector, 
	transform-vector, bw-noise, color-noise, warped-bw-noise, 
	warped-color-noise, blur, band-pass, grad-mag, grad-dir, 
        bump, ifs, warped-ifs, warp-abs, warp-rel, warp-by-grad.
</i>
</pre>
<p>
Each function takes a specified number of arguments and calculates and
returns an image of scalar (b/w) or vector (color) values.
</p><p>
Noise generators can create solid 2D scalar and vector noise at various
frequencies with random seeds passed as arguments so specific patterns can
be preserved between generations [figure 4f, and 4i].  The warped versions
of functions take <i>(U,V)</i> coordinates as arguments instead of using global
<i>(X,Y)</i> pixel coordinates, allowing the result to be distorted by an
arbitrary inverse mapping function [figure 4i].  Boolean operations (<em>and</em>, <em>or</em>, and <em>xor</em>) operate on each bit of floating-point
numbers and can cause fractal-like grid patterns [figure 4e].  Versions of
<em>sin</em> and <em>cos</em> which normalize their results between .0 and 1.0
instead of -1.0 and 1.0 can be useful.  Some functions such as blurs,
convolutions, and those that use gradients also use neighboring pixel
values to calculate their result [figure 4h].  <em>Band-pass</em> convolutions
can be performed using a difference of Gaussians filter which can enhance
edges.  Iterative function systems (<em>ifs</em>) can generate fractal
patterns and shapes.
</p><p>
</p><center>
<img src="./Karl Sims_ Artifical Evolution for Computer Graphics_files/ksf04.gif" width="60%"><p>
Figure 4:  Simple expression examples.
</p></center>
<p>
</p><pre>	(reading left to right, top to bottom)
	a. <i>X</i>
	b. <i>Y</i>
	c. <i>(abs X)</i>
	d. <i>(mod X (abs Y))</i>
	e. <i>(and X Y)</i>
	f. <i>(bw-noise .2 2)</i>
	g. <i>(color-noise .1 2)</i>
	h. <i>(grad-direction (bw-noise .15 2) .0 .0)</i>
	i. <i>(warped-color-noise (* X .2) Y .1 2)</i>
</pre>
<p>
Details of the specific implementations of these functions are not given
here because they are not as important as the methods used for combining
them into longer expressions.  Many other functions would be interesting to
include in this <em>function set</em>, but these have provided for a fairly
wide variety of resulting images.
</p><p>
Simple random expressions are generated by choosing a function at random
from the <em>function set</em> above, and then generating as many random
arguments as that function requires.  Arguments to these functions can be
either scalars or vectors, and either constant values or images of values.
Random arguments can be generated from the following forms:
</p><p>
	-  A random scalar value such as <i>.4</i><br>
	-  A random 3-element vector such as <i>#(.42 .23 .69)</i><br>
	-  A variable such as the <i>X</i> or <i>Y</i> pixel coordinates.<br>
	-  Another lisp expression which returns a b/w or color image.<br>
</p><p>
Most of the functions have been adapted to either coerce the arguments into
the required types, or perform differently according to the argument types
given to them.  Arguments to certain functions can optionally be restricted
to some subset of the available types.  For the most part these functions
receive and return images, and can be considered as image processing
operations.  Expressions are simply evaluated to produce images.  Figure 4
shows examples of some simple expressions and their resulting images.
</p><p>
Artificial evolution of these expressions is performed by first generating
and displaying a population of simple random expressions in a grid for
interactive selection.  The expressions of images selected by the user are
reproduced with mutations for each new generation such that more and more
complex expressions and more perceptually successful images can evolve.
Some images evolved with this process are shown in figures 9 to 13.
</p><p>
</p><h3>4.2 &nbsp; Mutating Symbolic Expressions</h3>
<p>
Symbolic expressions must be reproduced with mutations for evolution of
them to occur.  There are several properties of symbolic expression
mutation that are desirable.  Expressions should often be only slightly
modified, but sometimes significantly adjusted in structure and size.
Large random changes in genotype usually result in large jumps in phenotype
which are less likely to be improvements, but are necessary for extending
the expression to more complex forms.
</p><p>
A recursive mutation scheme is used to mutate expressions.  Lisp
expressions are traversed as tree structures and each node is in turn
subject to possible mutations.  Each type of mutation occurs at different
frequencies depending on the type of node:
</p><p>
</p><ol>
<li>
Any node can mutate into a new random expression.  This allows for large
changes, and usually results in a fairly significant alteration of the
phenotype.<p>
</p></li><li>
If the node is a scalar value, it can be adjusted by the addition of
some random amount.<p>
</p></li><li>
If the node is a vector, it can be adjusted by adding random amounts to
each element.<p>
</p></li><li>
If the node is a function, it can mutate into a different function.  For
example <i>(abs X)</i> might become <i>(cos X)</i>.  If this mutation occurs,
the arguments of the function are also adjusted if necessary to the correct
number and types.<p>
</p></li><li>
An expression can become the argument to a new random function.  Other
arguments are generated at random if necessary.  For example <i>X</i> might
become <i>(* X .3)</i>.<p>
</p></li><li>
An argument to a function can jump out and become the new value for that
node.  For example <i>(* X .3)</i> might become <i>X</i>.  This is the inverse of the
previous type of mutation.<p>
</p></li><li>
Finally, a node can become a copy of another node from the parent
expression.  For example <i>(+ (abs X) (* Y .6))</i> might become <i>(+ (abs (* Y
.6)) (* Y .6))</i>.  This causes effects similar to those caused by mating an
expression with itself.  It allows for sub-expressions to duplicate
themselves within the overall expression.
</li></ol>
<p>
Other types of mutations could certainly be implemented, but these are
sufficient for a reasonable balance of slight modifications and potential
for changes in complexity.
</p><p>
It is preferable to adjust the mutation frequencies such that a decrease in
complexity is slightly more probable than an increase.  This prevents the
expressions from drifting towards large and slow forms without necessarily
improving the results.  They should still easily evolve towards larger
sizes, but a larger size should be due to selection of improvements instead
of random mutations with no effect.
</p><p>
The relative frequencies for each type of mutation above can be adjusted
and experimented with.  The overall mutation frequency is scaled inversely
in proportion to the length of the parent expression.  This decreases the
probability of mutation at each node when the parent expression is large so
that some stability of the phenotypes is maintained.
</p><p>
The evaluation of expressions and display of the resulting images can
require significant calculation times as expressions increase in
complexity.  To keep image evolution at interactive speeds, estimates of
compute speeds are calculated for each expression by summing pre-computed
runtime averages for each function.  Slow expressions are eliminated before
ever being displayed to the user.  New offspring with random mutations are
generated and tested until fast enough expressions result.  In this way
automatic selection is combined with interactive selection.  If necessary,
this technique could also be performed to keep memory usage to a minimum.
</p><p>
</p><h3>4.3 &nbsp; Mating Symbolic Expressions</h3>
<p>
Symbolic expressions can be reproduced with sexual combinations to allow
sub-expressions from separately evolved individuals to be mixed into a
single individual.  Two methods for mating symbolic expressions are
described.
</p><p>
The first method requires the two parents to be somewhat similar in
structure.  The nodes in the expression trees of both parents are
simultaneously traversed and copied to make the new expression.  When a
difference is encountered between the parents, one of the two versions is
copied with equal probability.  For example, the following two parents can
be mated to generate four different expressions, two of which are equal to
the parents, and two of which have some portions from each parent:
</p><p>
</p><pre>	parent1: <i>(* (abs X) (mod X Y))</i>
	parent2: <i>(* (/ Y X) (* X -.7))</i>
<p>
	child1: <i>(* (abs X) (mod X Y))</i>
	child2: <i>(* (abs X) (* X -.7))</i>
	child3: <i>(* (/ Y X) (mod X Y))</i>
	child4: <i>(* (/ Y X) (* X -.7))</i>
</p></pre>
<p>
This method is often useful for combining similar expressions that each
have some desired property.  It usually generates offspring without very
large variations from the parents.  Two expressions with different root
nodes will not form any new combinations.  This might be compared to the
inability of two different species to mate and create viable offspring.
</p><p>
The second method for mating expressions combines the parents in a less
constrained way.  A node in the expression tree of one parent is chosen at
random and replaced by a node chosen at random from the other parent.  This
<em>crossing over</em> technique allows any part of the structure of one
parent to be inserted into any part of the other parent and permits parts
of even dissimilar expressions to be combined.  With this method, the
parent expressions above can generate 61 different child expressions -
many more than the 4 of the first method.
</p><p>
</p><h3>4.4 &nbsp; Evolving Volume Textures</h3>
<p>
A third variable, <i>Z</i>, is added to the list of available arguments to
enable functions to be evolved that calculate colors for each point in
<i>(X,Y,Z)</i> space.  The <em>function set</em> shown in section 4.1 is adjusted
for better results: 2D functions that require neighboring pixel values such
as convolutions and warps are removed, and 3D solid noise generating
functions are added.
</p><p>
These expressions are more difficult to visualize because they encompass
all of 3D space.  They are evaluated on the surfaces of spheres and planes
for fast previewing and selection as shown in figure 5.  Evolved volume
expressions can then be incorporated into procedural shading functions to
texture arbitrary objects.  This process allows complex volume textures
such as those described in <a href="http://www.karlsims.com/papers/siggraph91.html#Peachey">[18]</a> and <a href="http://www.karlsims.com/papers/siggraph91.html#Perlin">[19]</a> to be evolved
without requiring specific equations to be understood and carefully
adjusted by hand.  Figure 6 was generated by evolving three volume
texture expressions and then evaluating them at the surfaces positions of
three objects during the rendering process.
</p><p>
</p><center>
<img src="./Karl Sims_ Artifical Evolution for Computer Graphics_files/ksf05.gif" width="60%"><p>
Figure 5:  Parent with 19 random mutations.
</p></center>
<p>
</p><center>
<img src="./Karl Sims_ Artifical Evolution for Computer Graphics_files/ksf06.gif" width="60%"><p>
Figure 6:  Marble and wooden tori.
</p></center>
<p>
</p><h3>4.5 &nbsp; Evolving Animations</h3>
<p>
Several extensions to the image evolution system described above can be
used to evolve moving images.  Five methods for incorporating a temporal
dimension in symbolic expressions are proposed:
</p><p>
</p><ol>
<li>
Another input variable, <i>Time</i>, can be added to the list of available
arguments.  Expressions can be evolved that are functions of <i>X</i>,<i>Y</i>, and
<i>Time</i> such that different images are produced as the value of <i>Time</i> is
smoothly animated.  More computation is required to generate, display and
select samples because a sequence of images must be calculated.  An
alternate method of display involves displaying various slices of the
<i>(X,Y,Time)</i> space (although operations requiring neighboring pixel values
might not receive the correct information if the values of <i>Time</i> vary
between them). <p>
</p></li><li>
<em>Genetic cross dissolves</em> can be performed between two expressions
of similar structure.  Interpolation between two expressions is performed
by matching the expressions where they are identical and interpolating
between the results where they are different.  Results of differing
expression branches are first calculated and dissolved, and then used by
the remaining parts of the expression.  If the two expressions have
different root nodes, a conventional image dissolve will result.  If only
parts within their structures are different, interesting motions can occur.
This technique utilizes the existing genetic representation of evolved
still images to generate in-betweens for a smooth transition from one to
another.  It is an example of the usefulness of the alternate level of
control given by the underlying genetic information.  A series of frames
from a genetic cross dissolve are shown in figure 7.
<p>
</p><center>
<img src="./Karl Sims_ Artifical Evolution for Computer Graphics_files/ksf07.gif" width="60%"><p>
Figure 7: Frames from a ``genetic cross dissolve.''
</p></center>
<p>
</p></li><li>
An input image can be added to the list of available arguments to make
functions of <i>X</i>,<i>Y</i>, and <i>Image</i>.  The input image can then be animated and
processed by evaluating the expression multiple times for values of <i>Image</i>
corresponding to frames of another source of animation such as hand drawn
or traditional 3D computer graphics.  This is effectively a technique for
evolving complex image processing and warping functions that compute new
images from given input images.  Figure 8 was created in this way with an
input image of a human face.
<p>
</p><center>
<img src="./Karl Sims_ Artifical Evolution for Computer Graphics_files/ksf08.gif" width="60%"><p>
Figure 8: Fire of Faces.
</p></center>
<p>
</p></li><li>
The images that use the pixel coordinates <i>(X,Y)</i> to determine the
colors at each pixel can be animated by altering the mappings of <i>X</i> and
<i>Y</i> before the expression is evaluated.  Simple zooming and panning can be
performed as well as 3D perspective transformations and arbitrary patterns
of distortion.
<p>
</p></li><li>
Evolved expressions can be adjusted and experimented with by hand.  If
parameters in expressions are smoothly interpolated to new values, the
corresponding image will change in potentially interesting ways.  For
example, solid noise can be made to change frequency, colors can be
dissolved into new shades, and angles can be rotated.  This is another
example of utilizing the underlying genetic information to manipulate
images.  A small change in the expression can result in a powerful
alteration of the resulting image.
</li></ol>
<p>
Finally, the techniques above can be used together in various combinations
to make an even wider range of possibilities for evolving animations.
</p><p>
</p><h3>5 &nbsp; RESULTS</h3>
<p>
Evolution of 3D plant structures, images, solid textures, and animations
have been implemented on the Connection Machine <sup>(R)</sup> system CM-2, a data
parallel supercomputer <a href="http://www.karlsims.com/papers/siggraph91.html#cmtech">[27]</a><a href="http://www.karlsims.com/papers/siggraph91.html#Hillis87">[10]</a>.  The parallel
implementation details will not be discussed in this paper, but each
application is reasonably suited for highly parallel representation and
computation.  Lisp expression mutations and combinations are performed on a
<em>front-end</em> computer and the Connection Machine system is used to
evaluate the expression for all pixels in parallel using <em>Starlisp</em> and
display the resulting image.
</p><p>
3D Plant structures have been evolved and used in the animated short <em>Panspermia</em> <a href="http://www.karlsims.com/papers/siggraph91.html#Panspermia">[24]</a>.  A frame from this sequence is shown in
figure 3 which contains a variety of species created using these
techniques.  An interactive system for quickly growing, displaying, and
selecting sample structures allows a wide range of plant shapes to be
efficiently created by artificial evolution.  Populations of samples can be
displayed for selection in wire frame in a grid format as shown in figure
2, or displayed as separate higher-resolution images which can be
interactively flipped through by scrolling with a mouse.  Typically between
5 and 20 generations are necessary for acceptable structures to emerge.
</p><p>
Images, volume textures, and various animations have been created using
mutating symbolic expressions.  These sometimes require more generations to
evolve complex expressions that give interesting images - often at least 10
to 40 generations.  Again, an interactive tool for quickly displaying grids
of sample images to be selected amongst makes the evolution process
reasonably efficient.  [See figure 5.]  The number of possible
symbolic expressions of acceptable length is extremely large, and a wide
variety of textures and patterns can occur.  Completely unexpected kinds of
images have emerged.  Figure 9 was created from the following evolved
expression:
</p><p>
</p><pre><i>
	(round (log (+ y (color-grad (round (+ (abs (round 
        (log (+ y (color-grad (round (+ y (log (invert y) 15.5)) 
        x) 3.1 1.86 #(0.95 0.7 0.59) 1.35)) 0.19) x)) (log (invert
        y) 15.5)) x) 3.1 1.9 #(0.95 0.7 0.35) 1.35)) 0.19) x)
</i>
</pre>
<p>
</p><center>
<img src="./Karl Sims_ Artifical Evolution for Computer Graphics_files/ksf09.gif" width="60%"><p>
Figure 9
</p></center>
<p>
</p><center>
<img src="./Karl Sims_ Artifical Evolution for Computer Graphics_files/ksf10.gif" width="60%"><p>
Figure 10
</p></center>
<p>
</p><center>
<img src="./Karl Sims_ Artifical Evolution for Computer Graphics_files/ksf11.gif" width="60%"><p>
Figure 11
</p></center>
<p>
Figure 13 was created from this expression:
</p><p>
</p><pre><i>
	(sin (+ (- (grad-direction (blur (if (hsv-to-rgb (warped-
        color-noise #(0.57 0.73 0.92) (/ 1.85 (warped-color-
        noise x y 0.02 3.08)) 0.11 2.4)) #(0.54 0.73 0.59) #(1.06 
        0.82 0.06)) 3.1) 1.46 5.9) (hsv-to-rgb (warped-color-
        noise y (/ 4.5 (warped-color-noise y (/ x y) 2.4 2.4)) 
        0.02 2.4))) x))
</i>
</pre>
<p>
Note that expressions only five or six lines long can generate
images of fair complexity.  Equations such as these can be evolved from
scratch in timescales of only several minutes - probably much faster than
they could be designed.
</p><p>
Figures 10, 11, and 12 were also created from expressions of similar
lengths.  Fortunately, analysis of expressions is not required when using
these methods to create them.  Users usually stop attempting to understand
why each expression generates each image.  However, for those interested,
expressions for other figures are listed in the appendix.
</p><p>
Two different approaches of user selection behavior are possible.  The user
can have a goal in mind and select samples that are closer to that goal
until it is hopefully reached.  Alternatively, the user can follow the more
interesting samples as they occur without attempting to reach any specific
goal.
</p><p>
The results of these various types of evolved expressions can be saved in
the very concise form of the final genotypic expression itself.  This
facilitates keeping large libraries of evolved forms which can then be used
to contribute to further evolutions by mating them with other forms or
further evolving them in new directions.
</p><p>
</p><center>
<img src="./Karl Sims_ Artifical Evolution for Computer Graphics_files/ksf12.gif" width="90%"><p>
Figure 12
</p></center>
<p>
</p><center>
<img src="./Karl Sims_ Artifical Evolution for Computer Graphics_files/ksf13.gif" width="90%"><p>
	Figure 13
</p></center>
<p>
</p><h3>6 &nbsp; FUTURE WORK</h3>
<p>
Artificial evolution has many other possible applications for computer
graphics and animation.  Procedures that use various other forms of solid
noise could be explored, such as those that create objects, create density
functions, or warp objects <a href="http://www.karlsims.com/papers/siggraph91.html#Lewis">[15]</a><a href="http://www.karlsims.com/papers/siggraph91.html#Perlin89">[20]</a>.  Procedures could be
evolved that generate motion from a set of rules (possibly cellular
automata, or particle systems), or that control distributions and
characteristics of 2D objects such as lines, solid shapes, or brush
strokes.  Algorithms that use procedural construction rules to create 3D
objects from polygons, or functions that generate, manipulate, and combine
geometric primitives could also be explored.
</p><p>
These techniques might also make valuable tools in domains beyond computer
simulations.  New possibilities for shapes and textures could be explored
for use in product design or the fashion industry.
</p><p>
Several variations on the methods for artificial evolution described above
might make interesting experiments.  Mutation frequencies could be included
in the genotype itself so that they also can be mutated.  This might allow
for the evolution of evolvability <a href="http://www.karlsims.com/papers/siggraph91.html#Dawkins87">[4]</a>.  Frequencies from the
most successful evolutions could be kept as the defaults.
</p><p>
It might be interesting to attempt to automatically evolve a symbolic
expression that could generate a simple specific goal image.  An image
differencing function could be used to calculate a <em>fitness</em> based on
how close a test image was to the goal, and an expression could be searched
for by automatic selection.  Then, interactive selection could be used to
evolve further images starting with that expression.
</p><p>
Large amounts of information of all the human selection choices of many
evolutions could be saved and analyzed.  A difficult challenge would be to
create a system that could generalize and ``understand'' what makes an
image visually successful, and even generate other images that meet these
learned criteria.
</p><p>
Combinations of random variations and non-random variations using learned
information might be helpful.  If a user picks phenotypes in a certain
direction from the parent, mutations for the next generation might have a
tendency to continue in that same direction, causing evolution to have
``momentum.''
</p><p>
Also, combinations of evolution and the ability to apply specific
adjustments to the genotype might allow more user control over evolved
results.  Automatic ``genetic engineering'' could permit a user to request
an evolved image to be more blue, or a texture more grainy.
</p><p>
</p><h3>7 &nbsp; CONCLUSION</h3>
<p>
Artificial evolution has been demonstrated to be a potentially powerful
tool for the creation of procedurally generated structures, textures, and
motions.  Reproduction with random variations and survival of the visually
interesting can lead to useful results.  Representations for genotypes
which are not limited to fixed spaces and can grow in complexity have shown
to be worthwhile.
</p><p>
Evolution is a method for creating and exploring complexity that does not
require human understanding of the specific process involved.  This process
of artificial evolution could be considered as a system for helping the
user with creative explorations, or it might be considered as a system
which attempts to ``learn'' about human aesthetics from the user.  In
either case, it allows the user and computer to interactively work together
in a new way to produce results that neither could easily produce alone.
</p><p>
An important limiting factor in the usefulness of artificial evolution is
that samples need to be generated quickly enough such that it is
advantageous for the user to choose from random samples instead of
carefully adjusting new samples by hand.  The computer needs to generate
and display samples fast enough to keep the user interested while selecting
amongst them.  As computation becomes more powerful and available,
artificial evolution will hopefully become advantageous in more and more
domains.
</p><p>
</p><h3>8 &nbsp; Acknowledgments</h3>
<p>
Thanks to Lew Tucker, Jim Salem, Gary Oberbrunner, Matt Fitzgibbon, Dave
Sheppard, and Pattie Maes for help and support.  Thanks to Peter Schröder
for being a helpful and successful user of these tools.  Thanks to Luis
Ortiz and Katy Smith for help with document preparation.  And thanks to
Danny Hillis, Larry Yaeger, and Richard Dawkins for discussions and
inspiration.
</p><p>
</p><h3>	APPENDIX</h3>
<p>
Figure 5, Parent expression:
</p><p>
<i>
(warped-color-noise (warped-bw-noise (dissolve x 2.53 y) z 0.09 12.0)
</i>
(invert z) 0.05 -2.06)
</p><p>
Figure 6, Marble torus:
</p><p>
<i>
(dissolve (cos (and 0.25 #(0.43 0.73 0.74))) (log (+ (warped-bw-noise (min
z 11.1) (log (rotate-vector (+ (warped-bw-noise (cos x) (dissolve (cos (and
0.25 #(0.43 0.73 0.74))) (log (+ (warped-bw-noise (max (min z 8.26) (/ -0.5
#(0.82 0.39 0.19))) (log (+ (warped-bw-noise (cos x) z -0.04 0.89) #(0.82
0.39 0.19)) #(0.15 0.34 0.50)) -0.04 -3.0) y) #(0.15 0.34 0.50)) y) -0.04
-3.0) x) z y) #(0.15 0.34 0.5)) -0.02 -1.79) -0.4) #(-0.09 0.34 0.55))
-0.7)
</i>
</p><p>
Figure 7, Cross dissolve:
</p><p>
<i>
(hsv-to-rgb (bump (hsv-to-rgb (ifs 2.29 0.003 (dissolve 1.77 3.67 time) 2.6
0.1 (dissolve 5.2 3.2 time) -31.0 (dissolve 23.9 -7.4 time) (dissolve 1.13
9.5 time) (dissolve 4.8 0.16 time) 20.7 4.05 (dissolve 0.48 0.46 time)
(dissolve 2.94 -0.68 time) (dissolve 0.42 0.54 time) (dissolve 0.09 0.54
time))) (atan 2.25 (dissolve 0.1 0.11 time) 0.15) (dissolve 4.09 8.23 time)
(dissolve #(0.41 0.36 0.08) #(0.68 0.22 0.31) time) #(0.36 0.31 0.91)
(dissolve 6.2 4.3 time) (dissolve 0.16 0.40 time) (dissolve 2.08 0.23
time)))
</i>
</p><p>
Figure 8, Fire of Faces:
</p><p>
<i>
(+ (min 10.8 (warp-rel image image (bump image x 9.6 #(0.57 0.02 0.15)
#(0.52 0.03 0.38) 3.21 2.49 10.8))) (dissolve #(0.81 0.4 0.16) x (dissolve
y #(0.88 0.99 0.66) image)))
</i>
</p><p>
Figure 10:
</p><p>
<i>
(rotate-vector (log (+ y (color-grad (round (+ (abs (round (log #(0.01 0.67
0.86) 0.19) x)) (hsv-to-rgb (bump (if x 10.7 y) #(0.94 0.01 0.4) 0.78
#(0.18 0.28 0.58) #(0.4 0.92 0.58) 10.6 0.23 0.91))) x) 3.1 1.93 #(0.95 0.7
0.35) 3.03)) -0.03) x #(0.76 0.08 0.24))
</i>
</p><p>
Figure 11 is unfortunately ``extinct'' because it was created before the
genome saving utility was complete.
</p><p>
Figure 12:
</p><p>
<i>
(cos (round (atan (log (invert y) (+ (bump (+ (round x y) y) #(0.46 0.82
0.65) 0.02 #(0.1 0.06 0.1) #(0.99 0.06 0.41) 1.47 8.7 3.7) (color-grad
(round (+ y y) (log (invert x) (+ (invert y) (round (+ y x) (bump
(warped-ifs (round y y) y 0.08 0.06 7.4 1.65 6.1 0.54 3.1 0.26 0.73 15.8
5.7 8.9 0.49 7.2 15.6 0.98) #(0.46 0.82 0.65) 0.02 #(0.1 0.06 0.1) #(0.99
0.06 0.41) 0.83 8.7 2.6))))) 3.1 6.8 #(0.95 0.7 0.59) 0.57))) #(0.17 0.08
0.75) 0.37) (vector y 0.09 (cos (round y y)))))
</i>
</p><p>
</p><h3>	BIBLIOGRAPHY</h3>
<p>
</p><dl compact="">
<dt><a name="Aono">[1]</a></dt><dd>
Aono, M., and Kunii, T. L., ``Botanical Tree Image Generation,'' <em>IEEE
Computer Graphics and Applications</em>, Vol.4, No.5, May 1982.
<p>
</p></dd><dt><a name="Darwin">[2]</a></dt><dd>
Darwin, Charles, <em>The Origin of Species</em>, New American Library, Mentor
paperback, 1859.
<p>
</p></dd><dt><a name="Dawkins86">[3]</a></dt><dd>
Dawkins, Richard, <em>The Blind Watchmaker</em>, Harlow Logman, 1986.
<p>
</p></dd><dt><a name="Dawkins87">[4]</a></dt><dd>
Dawkins, Richard, ``The Evolution of Evolvability,'' <em>Artificial Life
Proceedings</em>, 1987, pp.201-220.
<p>
</p></dd><dt><a name="Goldberg">[5]</a></dt><dd>
Goldberg, D. E., <em>Genetic Algorithms in Search, Optimization, and
Machine Learning</em>, 1989, Addison-Wesley Publishing Co.
<p>
</p></dd><dt><a name="GA85">[6]</a></dt><dd>
Grenfenstette, J. J., <em>Proceedings of the First International
Conference on Genetic Algorithms and Their Applications</em>, Hillsdale, New
Jersey, Lawrence Erlbaum Associates, 1985.
<p>
</p></dd><dt><a name="GA87">[7]</a></dt><dd>
Grenfenstette, J. J., <em>Genetic Algorithms and Their Applications:
Proceedings of the Second International Conference on Genetic Algorithms</em>,
1987, (Hillsdale, New Jersey: Lawrence Erlbaum Associates.)
<p>
</p></dd><dt><a name="Haase">[8]</a></dt><dd>
Haase, K., ``Automated Discovery,'' <em>Machine Learning: Principles and
Techniques</em>, by Richard Forsyth, Chapman &amp;Hall 1989, pp.127-155.
<p>
</p></dd><dt><a name="Haggerty">[9]</a></dt><dd>
Haggerty, M., ``Evolution by Esthetics, an Interview with W. Latham and S.
Todd,'' <em>IEEE Computer Graphics</em>, Vol.11, No.2, March 1991, pp.5-9.
<p>
</p></dd><dt><a name="Hillis87">[10]</a></dt><dd>
Hillis, W. D., ``The Connection Machine,'' <em>Scientific American</em>,
Vol. 255, No. 6, June 1987.
<p>
</p></dd><dt><a name="Holland">[11]</a></dt><dd>
Holland, J. H., <em>Adaptation in Natural and Artificial Systems</em>, Ann
Arbor, MI: University of Michigan Press, 1975.
<p>
</p></dd><dt><a name="Koza90a">[12]</a></dt><dd>
Koza, J. R. ``Genetic Programming: A Paradigm for Genetically Breeding
Populations of Computer Programs to Solve Problems,'' Stanford University
Computer Science Department Technical Report STAN-CS-90-1314, June 1990.
<p>
</p></dd><dt><a name="Koza90b">[13]</a></dt><dd>
Koza, J. R. ``Evolution and Co-Evolution of Computer Programs to Control
Independently Acting Agents,'' <em>Conference on Simulation of Adaptive
Behavior</em> (SAB-90) Paris, Sept.24-28, 1990.
<p>
</p></dd><dt><a name="Lenat">[14]</a></dt><dd>
Lenat, D. B. and Brown,J.S. ``Why AM and EURISKO appear to work,'' <em>Artificial intelligence</em>, Vol.23, 1984, pp.269-294.
<p>
</p></dd><dt><a name="Lewis">[15]</a></dt><dd>
Lewis, J. P., ``Algorithms for Solid Noise Synthesis,'' <em>Computer
Graphics</em>, Vol.23, No.3, July 1989, pp.263-270.
<p>
</p></dd><dt><a name="Oppenheimer">[16]</a></dt><dd>
Oppenheimer, P.  ``Real time design and animation of fractal plants and
trees.''  <em>Computer Graphics</em>, Vol.20, No.4, 1986, pp.55-64.
<p>
</p></dd><dt><a name="Oppenheimer87">[17]</a></dt><dd>
Oppenheimer, P. ``The Artificial Menagerie'' <em>Artificial Life
Proceedings</em>, 1987, pp.251-274.
<p>
</p></dd><dt><a name="Peachey">[18]</a></dt><dd>
Peachy, D., ``Solid Texturing of Complex Surfaces,'' <em>Computer
Graphics</em> Vol.19, No.3, July 1985, pp.279-286.
<p>
</p></dd><dt><a name="Perlin">[19]</a></dt><dd>
Perlin, K., ``An Image Synthesizer,'' <em>Computer Graphics</em>, Vol.19,
No.3, July 1985, pp.287-296.
<p>
</p></dd><dt><a name="Perlin89">[20]</a></dt><dd>
Perlin, K., ``Hypertexture,'' <em>Computer Graphics</em>, Vol.23, No.3, July
1989, pp.253-262.
<p>
</p></dd><dt><a name="Prusinkiewicz">[21]</a></dt><dd>
Prusinkiewicz, P., Lindenmayer, A., and Hanan, J., ``Developmental
Models of Herbaceous Plants for Computer Imagery Purposes,'' <em>Computer Graphics</em>, Vol.22 No.4, 1988, pp.141-150.
<p>
</p></dd><dt><a name="Reffye">[22]</a></dt><dd>
Reffye, P., Edelin, C., Francon, J., Jaeger, M., Puech, C. ``Plant Models
Faithful to Botanical Structure and Development,'' <em>Computer Graphics</em>
Vol.22, No.4, 1988, pp.151-158.
<p>
</p></dd><dt><a name="GA89">[23]</a></dt><dd>
Schaffer, J. D., ``Proceedings of the Third international Conference on
Genetic Algorithms,'' June 1989, Morgan Kaufmann Publishers, Inc.
<p>
</p></dd><dt><a name="Panspermia">[24]</a></dt><dd>
Sims, K., <em>Panspermia</em>, Siggraph Video Review 1990.
<p>
</p></dd><dt><a name="Smith">[25]</a></dt><dd>
Smith, A. R., ``Plants, Fractals, and Formal Languages,'' 
<em>Computer Graphics</em>, Vol.18, No.3, July 1984, pp.1-10.
<p>
</p></dd><dt><a name="Steele">[26]</a></dt><dd>
Steele, G., <em>Common Lisp, The Language</em>, Digital Press, 1984.
<p>
</p></dd><dt><a name="cmtech">[27]</a></dt><dd>
Thinking Machines Corporation, <em>Connection Machine Model CM-2
Technical Summary</em>, technical report, May 1989.
<p>
</p></dd><dt><a name="Todd">[28]</a></dt><dd>
Todd, S. J. P., and Latham, W., ``Mutator, a Subjective Human Interface for
Evolution of Computer Sculptures,'' IBM United Kingdom Scientific Centre
Report 248, 1991.
<p>
</p></dd><dt><a name="Viennot">[29]</a></dt><dd>
Viennot, X., Eyrolles, G., Janey, N., and Arques, D., ``Combinatorial
Analysis of Ramified Patterns and Computer Imagery of Trees,'' <em>Computer Graphics</em>, Vol.23, No.3, July 1989, pp.31-40.
<p>
</p></dd></dl>
<hr>

</body></html>